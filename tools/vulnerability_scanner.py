"""
漏洞扫描工具
"""
from typing import Dict, Any, List, Optional
import httpx
import re
from urllib.parse import urljoin, urlparse, parse_qs
from utils.logger import log
from utils.url_helper import normalize_url


async def test_sql_injection(
    url: str,
    params: Optional[Dict[str, str]] = None,
    timeout: int = 10
) -> Dict[str, Any]:
    """
    SQL 注入测试

    Args:
        url: 目标 URL
        params: 参数字典
        timeout: 请求超时时间

    Returns:
        测试结果
    """
    # 规范化 URL
    url = normalize_url(url)

    sql_payloads = [
        "'",
        "\"",
        "' OR '1'='1",
        "\" OR \"1\"=\"1",
        "' OR '1'='1' --",
        "' OR '1'='1' /*",
        "admin' --",
        "admin' #",
        "' UNION SELECT NULL--",
        "1' AND '1'='1",
    ]

    vulnerabilities = []

    log.info(f"开始 SQL 注入测试: {url}")
    
    if params is None:
        params = {}
    
    async with httpx.AsyncClient(timeout=timeout, follow_redirects=False) as client:
        # 获取正常响应作为基准
        try:
            normal_response = await client.get(url, params=params)
            normal_length = len(normal_response.content)
        except Exception as e:
            log.error(f"获取基准响应失败: {str(e)}")
            return {"success": False, "error": str(e)}
        
        # 测试每个参数
        for param_name in params.keys():
            for payload in sql_payloads:
                test_params = params.copy()
                test_params[param_name] = payload
                
                try:
                    response = await client.get(url, params=test_params)
                    
                    # 检测 SQL 错误信息
                    sql_errors = [
                        "SQL syntax",
                        "mysql_fetch",
                        "ORA-",
                        "PostgreSQL",
                        "SQLite",
                        "ODBC",
                        "Microsoft SQL",
                    ]
                    
                    content = response.text.lower()
                    for error in sql_errors:
                        if error.lower() in content:
                            vuln = {
                                "parameter": param_name,
                                "payload": payload,
                                "error_type": error,
                                "status_code": response.status_code,
                                "evidence": content[:200]
                            }
                            vulnerabilities.append(vuln)
                            log.warning(f"可能存在 SQL 注入: {param_name}={payload}")
                            break
                    
                    # 检测响应长度异常
                    if abs(len(response.content) - normal_length) > 1000:
                        log.info(f"响应长度异常: {param_name}={payload}")
                        
                except Exception as e:
                    log.debug(f"测试失败: {param_name}={payload} - {str(e)}")
                    continue
    
    log.info(f"SQL 注入测试完成，发现 {len(vulnerabilities)} 个可能的漏洞")
    
    return {
        "success": True,
        "url": url,
        "vulnerabilities": vulnerabilities,
        "count": len(vulnerabilities)
    }


async def test_xss(
    url: str,
    params: Optional[Dict[str, str]] = None,
    timeout: int = 10
) -> Dict[str, Any]:
    """
    XSS 跨站脚本测试

    Args:
        url: 目标 URL
        params: 参数字典
        timeout: 请求超时时间

    Returns:
        测试结果
    """
    # 规范化 URL
    url = normalize_url(url)

    xss_payloads = [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert('XSS')>",
        "javascript:alert('XSS')",
        "<iframe src=javascript:alert('XSS')>",
        "<body onload=alert('XSS')>",
        "'\"><script>alert('XSS')</script>",
    ]

    vulnerabilities = []

    log.info(f"开始 XSS 测试: {url}")
    
    if params is None:
        params = {}
    
    async with httpx.AsyncClient(timeout=timeout, follow_redirects=False) as client:
        for param_name in params.keys():
            for payload in xss_payloads:
                test_params = params.copy()
                test_params[param_name] = payload
                
                try:
                    response = await client.get(url, params=test_params)
                    
                    # 检查 payload 是否被反射到响应中
                    if payload in response.text:
                        vuln = {
                            "parameter": param_name,
                            "payload": payload,
                            "type": "reflected",
                            "status_code": response.status_code,
                        }
                        vulnerabilities.append(vuln)
                        log.warning(f"可能存在反射型 XSS: {param_name}={payload}")
                        
                except Exception as e:
                    log.debug(f"测试失败: {param_name}={payload} - {str(e)}")
                    continue
    
    log.info(f"XSS 测试完成，发现 {len(vulnerabilities)} 个可能的漏洞")
    
    return {
        "success": True,
        "url": url,
        "vulnerabilities": vulnerabilities,
        "count": len(vulnerabilities)
    }


async def test_lfi(
    url: str,
    params: Optional[Dict[str, str]] = None,
    timeout: int = 10
) -> Dict[str, Any]:
    """
    本地文件包含 (LFI) 测试

    Args:
        url: 目标 URL
        params: 参数字典
        timeout: 请求超时时间

    Returns:
        测试结果
    """
    # 规范化 URL
    url = normalize_url(url)

    lfi_payloads = [
        "../../../etc/passwd",
        "..\\..\\..\\windows\\win.ini",
        "/etc/passwd",
        "C:\\windows\\win.ini",
        "....//....//....//etc/passwd",
        "..%2F..%2F..%2Fetc%2Fpasswd",
    ]

    vulnerabilities = []

    log.info(f"开始 LFI 测试: {url}")
    
    if params is None:
        params = {}
    
    async with httpx.AsyncClient(timeout=timeout, follow_redirects=False) as client:
        for param_name in params.keys():
            for payload in lfi_payloads:
                test_params = params.copy()
                test_params[param_name] = payload
                
                try:
                    response = await client.get(url, params=test_params)
                    
                    # 检测 Linux 系统文件特征
                    linux_patterns = [
                        r"root:.*:0:0:",
                        r"/bin/bash",
                        r"/bin/sh",
                    ]
                    
                    # 检测 Windows 系统文件特征
                    windows_patterns = [
                        r"\[fonts\]",
                        r"\[extensions\]",
                        r"for 16-bit app support",
                    ]
                    
                    content = response.text
                    
                    for pattern in linux_patterns + windows_patterns:
                        if re.search(pattern, content, re.IGNORECASE):
                            vuln = {
                                "parameter": param_name,
                                "payload": payload,
                                "pattern": pattern,
                                "status_code": response.status_code,
                            }
                            vulnerabilities.append(vuln)
                            log.warning(f"可能存在 LFI: {param_name}={payload}")
                            break
                            
                except Exception as e:
                    log.debug(f"测试失败: {param_name}={payload} - {str(e)}")
                    continue
    
    log.info(f"LFI 测试完成，发现 {len(vulnerabilities)} 个可能的漏洞")
    
    return {
        "success": True,
        "url": url,
        "vulnerabilities": vulnerabilities,
        "count": len(vulnerabilities)
    }


async def test_open_redirect(
    url: str,
    params: Optional[Dict[str, str]] = None,
    timeout: int = 10
) -> Dict[str, Any]:
    """
    开放重定向测试

    Args:
        url: 目标 URL
        params: 参数字典
        timeout: 请求超时时间

    Returns:
        测试结果
    """
    # 规范化 URL
    url = normalize_url(url)

    redirect_payloads = [
        "https://evil.com",
        "//evil.com",
        "https://google.com",
        "javascript:alert('XSS')",
    ]

    vulnerabilities = []

    log.info(f"开始开放重定向测试: {url}")
    
    if params is None:
        params = {}
    
    async with httpx.AsyncClient(timeout=timeout, follow_redirects=False) as client:
        for param_name in params.keys():
            for payload in redirect_payloads:
                test_params = params.copy()
                test_params[param_name] = payload
                
                try:
                    response = await client.get(url, params=test_params)
                    
                    # 检查是否发生重定向
                    if response.status_code in [301, 302, 303, 307, 308]:
                        location = response.headers.get("location", "")
                        if payload in location or "evil.com" in location:
                            vuln = {
                                "parameter": param_name,
                                "payload": payload,
                                "redirect_to": location,
                                "status_code": response.status_code,
                            }
                            vulnerabilities.append(vuln)
                            log.warning(f"可能存在开放重定向: {param_name}={payload}")
                            
                except Exception as e:
                    log.debug(f"测试失败: {param_name}={payload} - {str(e)}")
                    continue
    
    log.info(f"开放重定向测试完成，发现 {len(vulnerabilities)} 个可能的漏洞")
    
    return {
        "success": True,
        "url": url,
        "vulnerabilities": vulnerabilities,
        "count": len(vulnerabilities)
    }

